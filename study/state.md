# Stateful vs Stateless

## 상태 정보 (State)

* 시스템 내에서 과거에 발생했던 이벤트나 사용자 입력에 따른 결과 값입니다. <br>
&rarr; 현재의 시스템에 저장된 값이나 내용을 의미합니다.

* 예시
    * 유저 패킷에 따른 연산 및 유저 데이터 변경 총합은 현재 유저의 상태 정보
    * 파일의 생성 / 갱신 / 삭제의 데이터 변경의 총합은 현재 디스크의 상태 정보
    * 서버의 메모리 내용의 변경 총합은 서버의 상태 정보

* 일반적인 소프트웨어 시스템은 `deterministic`(결정론적)이기 때문에 <br>
동일한 입력 시퀀스가 주어질 경우 동일한 state 에 도달합니다. <br>
(참고 : random() 함수 자체도 동일한 srand()를 줄 경우 동일한 결과를 만들어 냅니다.)

* 어떤 시스템이 지속적으로 `state`를 기억해야 된다면 해당 시스템을 `stateful`하다고 합니다.

* 반면 state를 기억하지 않는 경우 `stateless`하다고 합니다.
    ```
    stateless 하다고 해서 전체 시스템에서 stateless 한 것이 아닙니다.
    REST 아키텍쳐에서 중요한 원칙 중 하나가 stateless 였는데, REST API를 쓰면 어떤 state 도 저장할 수 없다는 이야기가 아니라 
    각각의 REST API 자체가 stateless 하다는 것입니다.
    state를 저장하기 위해서 매번 어떤 token을 실어서 보내야하나? 고민한 부분을 생각하면,
    지금 한번 REST API를 호출할 떄의 내용과 다음 호출할 때 내용은 
    얘가 한번 앞에서 인증했기 때문에 봐준다가 아니라 매번 Access token을 보는 것입니다.
    ```
    ```
    만약 TCP를 쓰는 것을 생각해보면 TCP는 상대방에게 얼만큼의 데이터를 보냈는지, 그리고 상대방이 얼만큼 받았는지 기억합니다. 
    그렇다면 TCP 연결 자체는 stateful 합니다. 그런데 HTTP는 TCP 소켓을 사용합니다. REST API는 HTTP 위에서 동작합니다.
    연결 자체는 그렇게 되어있지만 상위 레벨에 인증이라고 하는 정보는 stateless 합니다. 
    ```

### State, Stateful, Stateless 의 예시 #1

#### 인증이 되었는지 여부는 state 에 해당합니다.

### `Case #1`
TCP 연결 정보 (= IP 주소, port) 기준으로 인증 여부를 저장하는 경우
* 즉, 인증이 되면 <IP 주소, port>를 기억하고, 같은 IP 주소, port에서 오는 트래픽은 "인증되었음"으로 처리합니다.
* 이 시나리오는 TCP 연결은 state를 기억하므로 TCP 연결은 stateful 합니다.

### `Case #2`
인증 여부에 대한 token을 발급하고, 요청마다 token을 포함하는 경우
* 이때 인증 여부는 토큰 검사만으로 가능하므로, <IP 주소, port>는 인증 여부와 관계가 없습니다.
* 즉, 이 시나리오에서 TCP 연결은 stateless 합니다.

### State, Stateful, Stateless 의 예시 #2

1. 과거의 유저 입력에 따라 현재 유저 정보가 결정되므로 유저 정보는 state 입니다.

2. DB는 유저 state 를 지속적으로 일관된 방식으로 저장하므로 stateful 합니다.

3. 만일 유저 요청을 처리하는 웹 어플리케이션이 어떤 정보도 저장하지 않고 모든 요청을 DB에 보내 처리한다면, <br>
유저는 아무 웹 애플리케이션 인스턴스에나 요청을 보낼 수 있으므로 해당 애플리케이션은 stateless 합니다.

4. 반면 DB로 관리되는 state 가 아니더라도, <br> 현재 유저가 채팅 중인 다른 유저 목록을 웹 애플리케이션 프로세스가 자신의 프로세스 메모리에 저장한다면, <br> 이 정보 역시 state 로 볼 수 있기 때문에, 이 경우는 stateful 합니다. <br>
(즉, 이때 유저는 반드시 동일한 웹 애플리케이션 프로세스와 통신해야 합니다.)

## Hard State vs Soft State

* Hard state 
    * State 변경을 유도하는 입력이 없는 한 그대로 유지되는 state

* Soft state
    * State 변경을 유도하는 입력이 없더라도 변경될 수 있는 state
    * 대표적으로 state가 일정 시간 뒤 Expire 되게 구현하는 방법이 있습니다. (로그인 정보, 소유권 등)

#### 예시
`유저가 명시적으로 로그아웃을 하지 않는 한 계속 로그인 상태로 남아있기` <br>
vs <br>
`유저가 로그아웃 처리하지 않았지만 일정 시간 뒤에 자동으로 로그아웃 처리되기`

## Soft State

### 필요성
* State 변경에 관련한 입력이 유실될 가능성이 있습니다.
* 입력이 유실된 경우 전체 시스템 복구 불가능 상태가 될 수 있습니다.
``` 
Ex) 경합(contention)을 피하기 위해, DB에 접근해야 하는 여러 서버 중 
권한을 획득한 서버만 DB에 접근하는데 해당 권한을 가진 서버가 갑자기 죽는다면?  
```

### 많이 사용되는 패턴
* 어떤 상태 정보를 일정 시간 동안 입력이 없으면 자동으로 expire 되게 하는 형태 

### 자동 expire 를 구현하는 프로그래밍 패턴

1. State 에 만료 시간 속성 추가합니다.

2. State 에 의존성을 갖는 대상은 만료 시간 갱신을 위해 `주기적으로 refresh 요청 전송` 합니다.

3. State 에 관리하는 쪽에서는 refresh 요청이 없는 경우 만료 시간 이후 state 파기합니다.

4. State 에 의존적인 대상은 state 가 변경되어 자신의 요청이 거절될 수 있음을 인지합니다.

### 앞의 DB에 쓰기 권한이 있는 서버만 쓰기 작업을 할 수 있게 하는 방식

1. DB 에 쓰기 작업을 해야되는 서버는 <br>
Redis나 Zookeeper 와 같은 시스템에 만료일을 기재 후 자신이 권한이 있음을 기재합니다.

2. Redis 나 Zookeeper 는 이 만료일이 지나면 해당 정보를 삭제합니다.

3. 해당 서버는 주기적으로 만료일을 갱신합니다.

4. 만료일 갱신 실패 시 본인이 권한을 포기한 적이 없어도 DB 에 쓰기 작업을 하지 못하게 처리합니다.

## 백엔드 구성 요소 간 공유 State 관리 방식

### 고려 사항

> 얼마나 빈번하게 state 가 갱신되는가?

> state 는 hard state 인가 soft state 인가?

### 방법들

* 분산 저장
    * 각 요소 (= 서버)들이 나눠서 state 를 관리합니다. (즉, 서버 프로세스 메모리 상에 저장)
    * 각 구성 요소는 RPC 나 MQ (Message Queue)를 통해 다른 요소가 관리하는 state 에 접근합니다.

* 중앙화 된 DB에 저장
    * In-memory : Redis, Zookeeper
    * Disk : SQL

## State 복제

* Replica &rarr; 복제본

* Replica 구현 방식
    * State 에 관련된 모든 입력 / 이벤트를 동일하게 replica 전달합니다.
    * 원본과 replica가 언제나 동일한 state를 갖게 됩니다.

### State 복제 예시 - DB Replica

* DB 만이 stateful 하다고 가정합니다. State 가 변경되는 모든 입력 / 이벤트는 복제가 되어야 합니다. <br> 즉, replica DB 에 전달되어야 합니다. 