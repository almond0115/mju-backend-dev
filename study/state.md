# Stateful vs Stateless

## 상태 정보 (State)

* 시스템 내에서 과거에 발생했던 이벤트나 사용자 입력에 따른 결과 값입니다. <br>
&rarr; 현재의 시스템에 저장된 값이나 내용을 의미합니다.

* 예시
    * 유저 패킷에 따른 연산 및 유저 데이터 변경 총합은 현재 유저의 상태 정보
    * 파일의 생성 / 갱신 / 삭제의 데이터 변경의 총합은 현재 디스크의 상태 정보
    * 서버의 메모리 내용의 변경 총합은 서버의 상태 정보

* 일반적인 소프트웨어 시스템은 `deterministic`(결정론적)이기 때문에 <br>
동일한 입력 시퀀스가 주어질 경우 동일한 state 에 도달합니다. <br>
(참고 : random() 함수 자체도 동일한 srand()를 줄 경우 동일한 결과를 만들어 냅니다.)

* 어떤 시스템이 지속적으로 `state`를 기억해야 된다면 해당 시스템을 `stateful`하다고 합니다.

* 반면 state를 기억하지 않는 경우 `stateless`하다고 합니다.
    ```
    stateless 하다고 해서 전체 시스템에서 stateless 한 것이 아닙니다.
    REST 아키텍쳐에서 중요한 원칙 중 하나가 stateless 였는데, REST API를 쓰면 어떤 state 도 저장할 수 없다는 이야기가 아니라 
    각각의 REST API 자체가 stateless 하다는 것입니다.
    state를 저장하기 위해서 매번 어떤 token을 실어서 보내야하나? 고민한 부분을 생각하면,
    지금 한번 REST API를 호출할 떄의 내용과 다음 호출할 때 내용은 
    얘가 한번 앞에서 인증했기 때문에 봐준다가 아니라 매번 Access token을 보는 것입니다.
    ```
    ```
    만약 TCP를 쓰는 것을 생각해보면 TCP는 상대방에게 얼만큼의 데이터를 보냈는지, 그리고 상대방이 얼만큼 받았는지 기억합니다. 
    그렇다면 TCP 연결 자체는 stateful 합니다. 그런데 HTTP는 TCP 소켓을 사용합니다. REST API는 HTTP 위에서 동작합니다.
    연결 자체는 그렇게 되어있지만 상위 레벨에 인증이라고 하는 정보는 stateless 합니다. 
    ```

### State, Stateful, Stateless 의 예시 #1

#### 인증이 되었는지 여부는 state 에 해당합니다.

### `Case #1`
TCP 연결 정보 (= IP 주소, port) 기준으로 인증 여부를 저장하는 경우
* 즉, 인증이 되면 <IP 주소, port>를 기억하고, 같은 IP 주소, port에서 오는 트래픽은 "인증되었음"으로 처리합니다.
* 이 시나리오는 TCP 연결은 state를 기억하므로 TCP 연결은 stateful 합니다.

### `Case #2`
인증 여부에 대한 token을 발급하고, 요청마다 token을 포함하는 경우
* 이때 인증 여부는 토큰 검사만으로 가능하므로, <IP 주소, port>는 인증 여부와 관계가 없습니다.
* 즉, 이 시나리오에서 TCP 연결은 stateless 합니다.

### State, Stateful, Stateless 의 예시 #2

1. 과거의 유저 입력에 따라 현재 유저 정보가 결정되므로 유저 정보는 state 입니다.

2. DB는 유저 state 를 지속적으로 일관된 방식으로 저장하므로 stateful 합니다.

3. 만일 유저 요청을 처리하는 웹 어플리케이션이 어떤 정보도 저장하지 않고 모든 요청을 DB에 보내 처리한다면, <br>
유저는 아무 웹 애플리케이션 인스턴스에나 요청을 보낼 수 있으므로 해당 애플리케이션은 stateless 합니다.

4. 반면 DB로 관리되는 state 가 아니더라도, <br> 현재 유저가 채팅 중인 다른 유저 목록을 웹 애플리케이션 프로세스가 자신의 프로세스 메모리에 저장한다면, <br> 이 정보 역시 state 로 볼 수 있기 때문에, 이 경우는 stateful 합니다. <br>
(즉, 이때 유저는 반드시 동일한 웹 애플리케이션 프로세스와 통신해야 합니다.)

## Hard State vs Soft State

* Hard state 
    * State 변경을 유도하는 입력이 없는 한 그대로 유지되는 state

* Soft state
    * State 변경을 유도하는 입력이 없더라도 변경될 수 있는 state
    * 대표적으로 state가 일정 시간 뒤 Expire 되게 구현하는 방법이 있습니다. (로그인 정보, 소유권 등)

#### 예시
`유저가 명시적으로 로그아웃을 하지 않는 한 계속 로그인 상태로 남아있기` <br>
vs <br>
`유저가 로그아웃 처리하지 않았지만 일정 시간 뒤에 자동으로 로그아웃 처리되기`

## Soft State

### 필요성
* State 변경에 관련한 입력이 유실될 가능성이 있습니다.
* 입력이 유실된 경우 전체 시스템 복구 불가능 상태가 될 수 있습니다.
``` 
ex) 경합(contention)을 피하기 위해, DB에 접근해야 하는 여러 서버 중 
권한을 획득한 서버만 DB에 접근하는데 해당 권한을 가진 서버가 갑자기 죽는다면?  
```

### 많이 사용되는 패턴
* 어떤 상태 정보를 일정 시간 동안 입력이 없으면 자동으로 expire 되게 하는 형태 

### 자동 expire 를 구현하는 프로그래밍 패턴

1. State 에 만료 시간 속성 추가합니다.

2. State 에 의존성을 갖는 대상은 만료 시간 갱신을 위해 `주기적으로 refresh 요청 전송` 합니다.

3. State 에 관리하는 쪽에서는 refresh 요청이 없는 경우 만료 시간 이후 state 파기합니다.

4. State 에 의존적인 대상은 state 가 변경되어 자신의 요청이 거절될 수 있음을 인지합니다.

### 앞의 DB에 쓰기 권한이 있는 서버만 쓰기 작업을 할 수 있게 하는 방식

1. DB 에 쓰기 작업을 해야되는 서버는 <br>
Redis나 Zookeeper 와 같은 시스템에 만료일을 기재 후 자신이 권한이 있음을 기재합니다.

2. Redis 나 Zookeeper 는 이 만료일이 지나면 해당 정보를 삭제합니다.

3. 해당 서버는 주기적으로 만료일을 갱신합니다.

4. 만료일 갱신 실패 시 본인이 권한을 포기한 적이 없어도 DB 에 쓰기 작업을 하지 못하게 처리합니다.

## 백엔드 구성 요소 간 공유 State 관리 방식

### 고려 사항

> 얼마나 빈번하게 state 가 갱신되는가?

> state 는 hard state 인가 soft state 인가?

### 방법들

* 분산 저장
    * 각 요소 (= 서버)들이 나눠서 state 를 관리합니다. (즉, 서버 프로세스 메모리 상에 저장)
    * 각 구성 요소는 RPC 나 MQ (Message Queue)를 통해 다른 요소가 관리하는 state 에 접근합니다.

* 중앙화 된 DB에 저장
    * In-memory : Redis, Zookeeper
    * Disk : SQL

## State 복제

* Replica &rarr; 복제본

* Replica 구현 방식
    * State 에 관련된 모든 입력 / 이벤트를 동일하게 replica 전달합니다.
    * 원본과 replica가 언제나 동일한 state를 갖게 됩니다.

### State 복제 예시 - DB Replica

* DB 만이 stateful 하다고 가정합니다. State 가 변경되는 모든 입력 / 이벤트는 복제가 되어야 합니다. 즉, replica DB 에 전달되어야 합니다. 

* 복제는 동기화 되어야 합니다. 즉, 복제가 완료될 때까지 state는 lock 되어야 합니다. <br>
&rarr; 복제의 숫자가 늘어날 수록 동기화에 시간이 소요됩니다.

### 2022년 10월 화재로 인한 카카오톡 장애 &rarr; 왜 이중화(Redundancy) 하지 않았나?

* 비용 문제
    * 화재 영향 받은 서버 수 3만 2천대
    * 이중화를 한다면 이 서버 대수 + 망 사용 비용이 증가

* 구현 난이도
    * 트래픽 많을 경우 state 저장하는 복제(replica) 간 동기화는 구현 난이도가 매우 높음

### Redundancy 증가의 Trade-off

* 복제(replica)를 늘려서 redundancy 를 올릴 수록 시스템은 반비례로 throughput 이 떨어짐 <br>
&rarr; 더 많은 수를 동기화 해야 하므로

* 앞의 예는 오직 DB만 stateful 하다는 단순화된 가정을 함.
&rarr; 실제로 중간에 있는 서버들 역시 stateful 한 경우도 있음 이는 성능 희생이 더 커짐을 의미함

### 데이터 내 서버 장애는 "예외" 상황인가?

* 서버 한대가 죽을 확률이 0.1% 라고 할 때, 3만 2천대가 있는 데이터 센터에서는 매일 32대의 서버가 죽습니다. <br>
&rarr; 서버가 죽는 것은 예외가 아니라 일상이고 복제에 대한 동기화 역시 이런 상황을 감안해야 합니다.

```
즉, 앞의 예에서 복제를 하다가 죽는 경우를 감안하지 않았는데 현실 세계에서는 복제를 하다가 
죽는 경우 자동적으로 재시도 및 복구가 가능해야 합니다. 
```

> 이 말은 throughput 은 더 떨어진다는 의미가 됩니다.

### Read Replica 와 Write Replica 대수

* State는 갱신될 때마다 선형 증가하는 버전 번호가 붙는다고 가정합니다.
    * Timestamp 혹은 DB 의 auto increment column 등등

* 이 떄 장애 상황을 고려하면서 복제를 하려면 다음 조건을 만족해야 합니다.
    ```
    Read 작업용 replica 대수 + Write 작업용 replica 대수 > 전체 replica 대수
    ex) replica 7대 있을 때 모든 read는 replica 4대, write는 replica 4대에 동시에 요청 해야 합니다. 
    그래야 겹치는 서버가 존재하고 state의 버전이 갱신된 것을 알아챌 수 있습니다.
    ```

* Read 에 replica 몇 대를 쓸지, Write 에 몇 대를 쓸지는 응용에 따라 다릅니다.
    ```
    읽기가 빨라야 하는 경우 : 적은 수의 read replica 수
    쓰기가 빨라야 하는 경우 : 적은 수의 write replica 수
    단 어느 한쪽의 성능을 올리면 다른 한쪽의 성능은 떨어집니다.
    통상적으로 1-n 형태, 과반-과반 형태, 2/3초과 ~ 1/3초과 형태를 사용합니다.
    ```

## Network Partitioning 문제

* 앞에서 장애를 고려할 때 read와 write는 겹치는 Replica 가 존재하게끔 대수를 조정해야 된다고 했습니다.

#### 만일 네트워크가 서버 대수를 완전히 반반으로 나누게끔 쪼개진다면?
&rarr; 이런 경우가 network partitioning 입니다. 분산 시스템 동기화 중 가장 까다로운 경우에 해당합니다.

* 물리적으로 떨어진 데이터센터 간의 복제는 network partitioning에 매우 취약합니다.

### Fate Sharing
* "살면 다 같이 살고, 죽으면 다 같이 죽게 해야 한다"는 원칙입니다.
* 소프트웨어 설계에 적응해보면, state는 이 state에 직접적 관련이 있는 요소에만 저장되어야 함을 뜻합니다. <br>
&rarr; 불필요한 요소가 state를 저장하여 stateful 하게 되면 장애 시 state 처리가 복잡해집니다.
    ```
    ex) state를 "caching"한 경우 (예: 서버 1번이 쓰기 권한을 깆고 있다"라고 저장), 
        장애 시 해당 state가 모두 사라져야 됨에도 cache에 남게 됩니다.
    ```

### 과연 전쟁이 나도 서비스는 유지될 수 있는가?
* read/write replica 개수 문제나 network partitioning 문제에서 언급했듯 과반 이상의 replica가 죽는 경우 더 이상 복제를 유지하면서 서비스를 할 수 없습니다.
* 또한 fate sharing 원칙에 따르면 stateful 한 구성요소가 늘어날 수록 시스템은 장애에 취약해집니다. (연관된 부분은 다 죽어야 하므로)
* TCP는 양쪽 끝단 (end-to-end) 에서만 state를 관리하고 중간의 네트워크 장비는 저장하는 정보 없이 header만 가지고 판단합니다. <br>
&rarr; 이 때문에 단 하나의 경로라도 살아있으면 여전히 통신이 가능합니다.

## Scale-up 과 Scale-out
### Scale-out : 대수를 늘려서 문제를 해결하는 방식
### Scale-up : 고사양으로 변경해서 문제를 해결하는 방식

#### 과도한 복제에 따른 throughput 감소는 잘 설계된 시스템이 아닌 이상 scale-out 이 제대로 동작하지 못할 가능성이 높습니다.

#### scale-up도 반드시 따라주어야 하는데, scale-up은 마음대로 올릴 수 있는 것이 아닙니다.
(100배 빠른 CPU와 NIC가 필요하다고 그게 가능하지 않은 것처럼)